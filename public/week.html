<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weekly Project Planning - Notion Logger</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/png" sizes="32x32" href="/commit-logger-favicon_1.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/commit-logger-favicon_2.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/commit-logger-favicon_3.png">
    <link rel="icon" type="image/png" sizes="192x192" href="/commit-logger-favicon_3.png">
    <link rel="icon" type="image/png" sizes="512x512" href="/commit-logger-favicon_3.png">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .header p {
            color: #7f8c8d;
            margin: 0;
        }
        
        .nav-links {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .nav-link {
            color: #3498db;
            text-decoration: none;
            padding: 8px 16px;
            border-radius: 6px;
            transition: background-color 0.2s ease;
        }
        
        .nav-link:hover {
            background-color: #e3f2fd;
        }
        
        .nav-link.active {
            background-color: #3498db;
            color: white;
        }
        
        .controls {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background-color 0.2s ease;
        }
        
        .btn:hover {
            background: #2980b9;
        }
        
        .btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }
        
        .btn.success {
            background: #27ae60;
        }
        
        .btn.success:hover {
            background: #229954;
        }
        
        .status {
            font-size: 14px;
            color: #7f8c8d;
        }
        
        .project-card {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            text-align: center;
        }
        
        .project-header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 25px;
        }
        
        .project-emoji {
            font-size: 32px;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
        }
        
        .color-square {
            width: 48px;
            height: 48px;
            border-radius: 8px;
            border: 2px solid rgba(0, 0, 0, 0.1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        
        .color-square:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        
        .project-info h2 {
            margin: 0 0 8px 0;
            color: #2c3e50;
            font-size: 24px;
        }
        
        .project-stats {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            font-size: 16px;
            color: #7f8c8d;
        }
        
        .stat {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .category-selector {
            margin-bottom: 30px;
        }
        
        .category-selector label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #2c3e50;
            font-size: 16px;
        }
        
        .selector-row {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            margin-bottom: 30px;
        }
        
        .category-selector,
        .status-selector {
            flex: 1;
            min-width: 0;
        }
        
        .category-selector select,
        .category-selector input,
        .status-selector select {
            width: 100%;
            max-width: 300px;
            padding: 12px 16px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            margin: 0 auto;
            display: block;
        }
        
        /* Responsive behavior for narrow screens */
        @media (max-width: 768px) {
            .selector-row {
                flex-direction: column;
                gap: 15px;
            }
            
            .category-selector,
            .status-selector {
                flex: none;
            }
        }
        
        .questions {
            margin-bottom: 30px;
        }
        
        .question {
            margin-bottom: 25px;
            text-align: left;
        }
        
        .question label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #2c3e50;
            font-size: 16px;
        }
        
        .question textarea {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            min-height: 80px;
            resize: vertical;
        }
        
        .rating-bubbles {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin: 15px 0;
        }
        
        .rating-bubble {
            width: 40px;
            height: 40px;
            border: 2px solid #ddd;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            background: white;
            color: #7f8c8d;
        }
        
        .rating-bubble:hover {
            border-color: #3498db;
            background: #e3f2fd;
            color: #3498db;
        }
        
        .rating-bubble.selected {
            border-color: #3498db;
            background: #3498db;
            color: white;
        }
        
        .rating-labels {
            display: flex;
            justify-content: space-between;
            color: #7f8c8d;
            font-size: 14px;
            margin-top: 8px;
        }
        
        .navigation-buttons {
            display: flex;
            justify-content: space-between;
            gap: 15px;
        }
        
        .progress-indicator {
            text-align: center;
            margin-bottom: 20px;
            color: #7f8c8d;
            font-size: 14px;
        }
        
        .progress-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        
        .ignore-done-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 12px;
            color: #666;
            user-select: none;
        }
        
        .ignore-done-checkbox input[type="checkbox"] {
            display: none;
        }
        
        .ignore-done-checkbox .checkmark {
            width: 16px;
            height: 16px;
            border: 2px solid #ddd;
            border-radius: 3px;
            background: white;
            position: relative;
            transition: all 0.2s ease;
        }
        
        .ignore-done-checkbox input[type="checkbox"]:checked + .checkmark {
            background: #3498db;
            border-color: #3498db;
        }
        
        .ignore-done-checkbox input[type="checkbox"]:checked + .checkmark::after {
            content: '';
            position: absolute;
            left: 4px;
            top: 1px;
            width: 4px;
            height: 8px;
            border: solid white;
            border-width: 0 2px 2px 0;
            transform: rotate(45deg);
        }
        
        .ignore-done-checkbox:hover .checkmark {
            border-color: #3498db;
        }
        
        .weekly-plan {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-top: 30px;
        }
        
        .weekly-plan h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .plan-categories {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        
        .plan-category {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
        }
        
        .plan-category h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            border-bottom: 2px solid #3498db;
            padding-bottom: 8px;
        }
        
        .plan-project {
            background: white;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 15px;
            border-left: 3px solid #3498db;
        }
        
        .plan-project h4 {
            margin: 0 0 10px 0;
            color: #2c3e50;
        }
        
        .plan-details {
            margin-top: 10px;
        }
        
        .plan-details h5 {
            margin: 0 0 8px 0;
            color: #7f8c8d;
            font-size: 14px;
        }
        
        .plan-details p {
            margin: 0 0 8px 0;
            color: #2c3e50;
            font-size: 14px;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #7f8c8d;
        }
        
        .error {
            background: #fee;
            color: #c33;
            padding: 15px;
            border-radius: 6px;
            margin: 20px 0;
            border: 1px solid #fcc;
        }
        
        .hidden {
            display: none;
        }
        
        .completion-message {
            text-align: center;
            padding: 20px;
            color: #27ae60;
            font-size: 16px;
        }
        
        .completion-indicator {
            background: #27ae60;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
            display: inline-block;
        }
        
        /* Enhanced weekly plan styling */
        .plan-summary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        
        .focus-category {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .highlight {
            background: #ffd700;
            color: #333;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: bold;
        }
        
        .project-recommendations {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }
        
        .recommendation {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .recommendation.full-width {
            grid-column: 1 / -1;
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .recommendation h5 {
            margin: 0 0 15px 0;
            font-size: 18px;
        }
        
        .scoring-breakdown {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .base-calculation {
            font-family: 'Courier New', monospace;
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 12px;
            border-radius: 4px;
            margin: 10px 0;
            border-left: 3px solid #4CAF50;
        }
        
        .tie-break-calculation {
            font-family: 'Courier New', monospace;
            background: rgba(255, 215, 0, 0.15);
            padding: 8px 12px;
            border-radius: 4px;
            margin: 10px 0;
            border-left: 3px solid #ffd700;
            color: #ffd700;
        }
        
        .tie-break-tooltip {
            position: relative;
            cursor: help;
            text-decoration: underline;
            text-decoration-style: dotted;
        }
        
        .tie-break-tooltip:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            margin-bottom: 5px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .tie-break-tooltip:hover::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.9);
            margin-bottom: -5px;
            z-index: 1000;
        }
        
        .recommendation p {
            margin: 8px 0;
            opacity: 0.9;
        }
        
        .tangent-note, .focus-note {
            font-style: italic;
            opacity: 0.8;
            font-size: 14px;
            margin-top: 10px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }
        
        .tie-break-info {
            font-size: 12px;
            opacity: 0.9;
            margin-top: 5px;
            padding: 4px 8px;
            background: rgba(255, 215, 0, 0.2);
            border-radius: 4px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            color: #ffd700;
        }
        
        .category-breakdown {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
        }
        
        .plan-category {
            margin-bottom: 30px;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #e1e8ed;
        }
        
        .plan-category.focus-category {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
        }
        
        .category-stats {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 15px 0;
        }
        
        .stat {
            background: rgba(255, 255, 255, 0.2);
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
        }
        
        .plan-category.focus-category .stat {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .plan-project {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            margin: 10px 0;
            border-left: 4px solid #dee2e6;
        }
        
        .plan-category.focus-category .plan-project {
            background: rgba(255, 255, 255, 0.1);
            border-left-color: #ffd700;
        }
        
        .plan-project.priority-5 { border-left-color: #28a745; }
        .plan-project.priority-4 { border-left-color: #17a2b8; }
        .plan-project.priority-3 { border-left-color: #ffc107; }
        .plan-project.priority-2 { border-left-color: #fd7e14; }
        .plan-project.priority-1 { border-left-color: #dc3545; }
        
        .project-scores {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }
        
        .priority-score, .base-score, .head-score, .heart-score {
            background: #e9ecef;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
        }
        
        .tie-break-badge {
            background: #fff3cd;
            color: #856404;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            border: 1px solid #ffeaa7;
        }
        
        .plan-category.focus-category .priority-score,
        .plan-category.focus-category .head-score,
        .plan-category.focus-category .heart-score {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }
        
        .status-badge {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .status-active { background: #d4edda; color: #155724; }
        .status-planning { background: #fff3cd; color: #856404; }
        .status-done { background: #d1ecf1; color: #0c5460; }
        .status-released { background: #e2e3e5; color: #383d41; }
        .status-unknown { background: #f8d7da; color: #721c24; }
        
        /* Spinning animation for sync button */
        .btn.spinning {
            position: relative;
            pointer-events: none;
            overflow: hidden;
        }
        
        .btn.spinning::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            margin: -10px 0 0 -10px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #ffffff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            z-index: 1;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .btn.spinning .sync-text {
            opacity: 0.3;
            transition: opacity 0.2s ease;
        }
        
        /* Ensure the spinning animation is visible */
        .btn.spinning:not(:disabled)::before {
            display: block;
        }
        
        /* Focus Input Section Styles */
        .focus-input-section {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-top: 30px;
            border: 2px solid #3498db;
        }
        
        .focus-input-section h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .focus-input-section p {
            color: #7f8c8d;
            text-align: center;
            margin-bottom: 25px;
        }
        
        .focus-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin-bottom: 25px;
        }
        
        .focus-input {
            display: flex;
            flex-direction: column;
        }
        
        .focus-input label {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 8px;
            font-size: 16px;
        }
        
        .focus-input input {
            padding: 12px 16px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.2s ease;
        }
        
        .focus-input input:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }
        
        .focus-input small {
            color: #7f8c8d;
            font-size: 12px;
            margin-top: 5px;
        }
        
        .focus-actions {
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        
        /* Saved Focus Display Styles */
        .saved-focus-display {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 12px;
            padding: 25px;
            margin-top: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        
        .saved-focus-display h3 {
            margin-bottom: 20px;
            text-align: center;
        }
        
        .focus-display {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .focus-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .focus-item h4 {
            margin: 0 0 10px 0;
            font-size: 16px;
        }
        
        .focus-item p {
            margin: 0;
            font-size: 14px;
            opacity: 0.9;
            line-height: 1.4;
        }
        
        /* Responsive design for focus inputs */
        @media (max-width: 768px) {
            .focus-inputs {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .focus-display {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .focus-actions {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>📅 Weekly Project Planning</h1>
        <p>Review your projects one by one and plan for the week ahead</p>
    </div>
    
    <div class="nav-links">
        <a href="/" class="nav-link">📊 Activity View</a>
        <a href="/week" class="nav-link active">📅 Weekly Planning</a>
        <a href="/projects" class="nav-link">📁 Projects</a>
        <a href="/progress" class="nav-link">📊 Progress</a>
    </div>
    
    <div class="controls">
        <button id="refresh-btn" class="btn">🔄 Refresh Data</button>
        <button id="generate-plan-btn" class="btn" disabled>📋 Generate Weekly Plan</button>
        <button id="save-plan-btn" class="btn" disabled>💾 Save Plan</button>
        <button id="sync-notion-btn" class="btn" disabled><span class="sync-text">🔄 Sync to Notion</span></button>
        <button id="load-plans-btn" class="btn">📂 Load Previous Plans</button>
        <button id="color-customize-btn" class="btn" onclick="openColorCustomizer()">🎨 Customize Colors</button>
        <div class="status" id="status">Ready to load project data</div>
    </div>
    
    <div id="loading" class="loading">
        <p>Loading project data...</p>
    </div>
    
    <div id="error" class="error hidden"></div>
    
    <div id="progress-indicator" class="progress-indicator hidden">
        <div class="progress-controls">
            <span id="progress-text"></span>
            <label class="ignore-done-checkbox">
                <input type="checkbox" id="ignore-done-projects" checked>
                <span class="checkmark"></span>
                Ignore done/retired projects
            </label>
        </div>
    </div>
    
    <div id="project-container" class="project-card hidden"></div>
    
            <div id="completion-message" class="completion-message hidden">
            <div class="completion-indicator">⚠️ Some Projects Need Ratings</div>
            <p id="completion-status" style="margin-top: 10px; font-size: 14px;">Click "Generate Weekly Plan" to see your summary.</p>
            <button id="go-back-btn" class="btn" onclick="goBackToIncomplete()" style="margin-top: 10px; font-size: 12px; padding: 8px 16px;">← Go Back to Incomplete</button>
        </div>
    
    <div id="weekly-plan" class="weekly-plan hidden">
        <h2>📋 Your Weekly Project Plan</h2>
        <div id="plan-content"></div>
        
        <!-- Primary and Tangent Focus Input Section -->
        <div id="focus-input-section" class="focus-input-section hidden">
            <h3>🎯 Declare Your Weekly Focus</h3>
            <p>After reviewing your plan, declare your Primary and Tangent focus for this week:</p>
            
            <div class="focus-inputs">
                <div class="focus-input">
                    <label for="primary-focus">🎯 Primary Focus:</label>
                    <input type="text" id="primary-focus" placeholder="What's your main focus this week?" maxlength="200">
                    <small>Your primary project or goal for the week</small>
                </div>
                
                <div class="focus-input">
                    <label for="tangent-focus">🌟 Tangent Focus:</label>
                    <input type="text" id="tangent-focus" placeholder="What's your tangent/exploration focus?" maxlength="200">
                    <small>Something you want to explore or work on when you have spare time</small>
                </div>
            </div>
            
            <div class="focus-actions">
                <button id="save-focus-btn" class="btn">💾 Save Focus</button>
                <button id="skip-focus-btn" class="btn" style="background: #95a5a6;">⏭️ Skip for Now</button>
            </div>
        </div>
        
        <!-- Saved Focus Display -->
        <div id="saved-focus-display" class="saved-focus-display hidden">
            <h3>🎯 Your Weekly Focus</h3>
            <div class="focus-display">
                <div class="focus-item primary">
                    <h4>🎯 Primary Focus</h4>
                    <p id="saved-primary-focus"></p>
                </div>
                <div class="focus-item tangent">
                    <h4>🌟 Tangent Focus</h4>
                    <p id="saved-tangent-focus"></p>
                </div>
            </div>
            <button id="edit-focus-btn" class="btn" style="background: #f39c12;">✏️ Edit Focus</button>
        </div>
    </div>
    
    <script>
        let projectData = [];
        let projectColors = {};
        let categories = [];
        let userAnswers = {};
        let currentProjectIndex = 0;
        let weeklyFocus = {
            primary: '',
            tangent: ''
        };
        
        // Load saved data from localStorage
        function loadSavedData() {
            try {
                const saved = localStorage.getItem('weeklyPlanningData');
                if (saved) {
                    const data = JSON.parse(saved);
                    userAnswers = data.userAnswers || {};
                    categories = data.categories || [];
                    currentProjectIndex = data.currentProjectIndex || 0;
                    weeklyFocus = data.weeklyFocus || { primary: '', tangent: '' };
                    console.log('📥 Loaded saved data from localStorage');
                    console.log('🔍 weeklyFocus loaded:', weeklyFocus);
                } else {
                    console.log('📥 No saved data found in localStorage');
                }
            } catch (error) {
                console.error('❌ Error loading saved data:', error);
                console.log('📥 No saved data found in localStorage');
            }
            
            // Load checkbox state
            const ignoreDone = localStorage.getItem('ignoreDoneProjects');
            if (ignoreDone !== null) {
                const checkbox = document.getElementById('ignore-done-projects');
                if (checkbox) {
                    checkbox.checked = ignoreDone === 'true';
                }
            }
            
            // Test sorting logic on page load
            testSortingLogic();
        }
        
        // Comprehensive project sorting function
        // Sorts by: 1) Total score (highest first), 2) Status priority, 3) Alphabetical
        // Status priority order (highest to lowest):
        // - active (6): Currently being worked on
        // - planning (5): Actively shaping into something concrete  
        // - idea (4): Just a spark or rough concept
        // - paused (3): Work stopped, likely to resume later
        // - unknown (2): Status not yet determined
        // - done/released (1): Completed or publicly launched
        // - parking-lot/abandoned (0): Not in current cycle or abandoned
        //
        // This function is used in:
        // - Category breakdown display (sortProjectsByPriority(projects))
        // - Project recommendations (findNextBestProject with 'priorityScore' sortBy)
        // - Main focus selection (sortProjectsByPriority for focus category projects)
        //
        // Expected behavior:
        // - Projects with same score are sorted by status priority (active > planning > idea > paused > unknown > done/released > parking-lot/abandoned)
        // - Projects with same score and status are sorted alphabetically
        // - Edge cases (null, empty arrays, invalid projects) are handled gracefully
        function sortProjectsByPriority(projects) {
            // Handle edge cases
            if (!Array.isArray(projects) || projects.length === 0) {
                return projects;
            }
            
            // Filter out projects without required properties
            const validProjects = projects.filter(project => 
                project && 
                typeof project.name === 'string' && 
                typeof project.priorityScore === 'number'
            );
            
            if (validProjects.length === 0) {
                console.warn('⚠️ No valid projects to sort');
                return projects;
            }
            
            // Define status priority order (higher index = higher priority)
            const statusPriority = {
                'active': 6,
                'planning': 5,
                'idea': 4,
                'paused': 3,
                'unknown': 2,
                'done': 1,
                'released': 1,
                'parking-lot': 0,
                'abandoned': 0
            };
            
            const sorted = validProjects.sort((a, b) => {
                // First: sort by total score (highest first)
                if (a.priorityScore !== b.priorityScore) {
                    return b.priorityScore - a.priorityScore;
                }
                
                // Second: if scores are tied, sort by status priority
                const aStatusPriority = statusPriority[a.status] || 0;
                const bStatusPriority = statusPriority[b.status] || 0;
                if (aStatusPriority !== bStatusPriority) {
                    console.log(`🔄 Score tie resolved by status: ${a.name} (${a.status} [${aStatusPriority}]) vs ${b.name} (${b.status} [${bStatusPriority}])`);
                    return bStatusPriority - aStatusPriority;
                }
                
                // Third: if status is also tied, sort alphabetically
                console.log(`🔄 Score and status tie resolved alphabetically: ${a.name} vs ${b.name}`);
                return a.name.localeCompare(b.name);
            });
            
            // Debug logging for sorting results
            if (sorted.length > 1) {
                console.log('🔄 Project sorting applied:');
                sorted.forEach((project, index) => {
                    const statusPriorityValue = statusPriority[project.status] || 0;
                    console.log(`  ${index + 1}. ${project.name} (Score: ${project.priorityScore}, Status: ${project.status} [${statusPriorityValue}])`);
                });
                
                // Log any tie-breaking decisions
                for (let i = 0; i < sorted.length - 1; i++) {
                    const current = sorted[i];
                    const next = sorted[i + 1];
                    
                    if (current.priorityScore === next.priorityScore) {
                        const currentStatusPriority = statusPriority[current.status] || 0;
                        const nextStatusPriority = statusPriority[next.status] || 0;
                        
                        if (currentStatusPriority === nextStatusPriority) {
                            console.log(`📝 Alphabetical tie-break: ${current.name} comes before ${next.name}`);
                        } else {
                            console.log(`📝 Status tie-break: ${current.name} (${current.status} [${currentStatusPriority}]) comes before ${next.name} (${next.status} [${nextStatusPriority}])`);
                        }
                    }
                }
            }
            
            return sorted;
        }
        
        // Save data to localStorage
        function saveData() {
            try {
                const dataToSave = {
                    userAnswers,
                    categories,
                    currentProjectIndex,
                    weeklyFocus,
                    timestamp: Date.now()
                };
                localStorage.setItem('weeklyPlanningData', JSON.stringify(dataToSave));
                console.log('💾 Saved data to localStorage');
                console.log('📊 Data saved:', dataToSave);
            } catch (error) {
                console.warn('⚠️ Could not save data:', error);
            }
        }
        
        // Load weekly data
        async function loadWeeklyData() {
            try {
                showLoading(true);
                hideError();
                
                const response = await fetch('/api/weekly-data');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                
                if (result.success) {
                    projectData = result.projects;
                    projectColors = result.projectColors;
                    
                    // Merge saved categories with server categories
                    const savedCategories = categories || [];
                    const serverCategories = result.categories || [];
                    categories = [...new Set([...savedCategories, ...serverCategories])];
                    
                    // Apply saved categories, status, and ratings to project data
                    projectData.forEach(project => {
                        const savedProject = userAnswers[project.name];
                        if (savedProject) {
                            if (savedProject.category) {
                                project.category = savedProject.category;
                                console.log(`📝 Applied category "${savedProject.category}" to ${project.name}`);
                            }
                            if (savedProject.status) {
                                project.status = savedProject.status;
                                console.log(`📝 Applied status "${savedProject.status}" to ${project.name}`);
                            }
                            if (savedProject.head) {
                                project.head = savedProject.head;
                                console.log(`📝 Applied head rating "${savedProject.head}" to ${project.name}`);
                            }
                            if (savedProject.heart) {
                                project.heart = savedProject.heart;
                                console.log(`📝 Applied heart rating "${savedProject.heart}" to ${project.name}`);
                            }
                        }
                    });
                    
                    // Ensure userAnswers is properly populated for UI display
                    projectData.forEach(project => {
                        if (!userAnswers[project.name]) {
                            userAnswers[project.name] = {};
                        }
                        // Ensure head/heart ratings are in userAnswers for UI display
                        if (project.head && !userAnswers[project.name].head) {
                            userAnswers[project.name].head = project.head;
                        }
                        if (project.heart && !userAnswers[project.name].heart) {
                            userAnswers[project.name].heart = project.heart;
                        }
                    });
                    
                    // Debug logging to see what's being loaded
                    console.log('📥 Loaded project data:', projectData);
                    console.log('📥 Loaded user answers:', userAnswers);
                    
                    // Debug: Check what's actually in userAnswers for each project
                    Object.keys(userAnswers).forEach(projectName => {
                        const answers = userAnswers[projectName];
                        console.log(`🔍 ${projectName}:`, answers);
                    });
                    
                    // Show the current project after data is loaded
                    showCurrentProject();
                    
                    if (projectData.length === 0) {
                        updateStatus('No project activity found in the last 28 days. Try fetching data from Notion first.');
                        document.getElementById('generate-plan-btn').disabled = true;
                        
                        // Show message with link to main page
                        const container = document.getElementById('project-container');
                        container.innerHTML = `
                            <div style="text-align: center; color: #7f8c8d;">
                                <p>No project activity found in the last 28 days.</p>
                                <p>Visit the <a href="/" style="color: #3498db;">Activity View</a> to fetch data from Notion first.</p>
                            </div>
                        `;
                        container.classList.remove('hidden');
                    } else {
                        currentProjectIndex = 0;
                        showCurrentProject();
                        updateStatus(`Loaded ${projectData.length} projects. Review them one by one.`);
                        document.getElementById('generate-plan-btn').disabled = true;
                    }
                } else {
                    throw new Error(result.error || 'Failed to load data');
                }
                
            } catch (error) {
                console.error('Error loading weekly data:', error);
                showError(`Failed to load project data: ${error.message}`);
                document.getElementById('generate-plan-btn').disabled = true;
            } finally {
                showLoading(false);
            }
        }
        
        // Show current project
        function showCurrentProject() {
            const filteredProjects = getFilteredProjects();
            if (currentProjectIndex >= filteredProjects.length) {
                showCompletionMessage();
                return;
            }
            
            const project = filteredProjects[currentProjectIndex];
            const container = document.getElementById('project-container');
            
            // Debug logging for current project
            console.log(`🎯 Showing project: ${project.name}`);
            console.log(`   - Project status: ${project.status}`);
            console.log(`   - User answer status: ${getAnswer(project.name, 'status')}`);
            console.log(`   - Project category: ${project.category}`);
            console.log(`   - User answer category: ${getAnswer(project.name, 'category')}`);
            console.log(`   - Project head: ${project.head}`);
            console.log(`   - User answer head: ${getAnswer(project.name, 'head')}`);
            console.log(`   - Project heart: ${project.heart}`);
            console.log(`   - User answer heart: ${getAnswer(project.name, 'heart')}`);
            console.log(`   - Full userAnswers for ${project.name}:`, userAnswers[project.name]);
            
            const lastActivity = project.lastActivity ? new Date(project.lastActivity).toLocaleDateString() : 'Unknown';
            
            container.innerHTML = `
                <div class="project-header">
                    <div class="project-emoji">${getProjectColor(project.name)}</div>
                    <div class="project-info">
                        <h2>${project.name}</h2>
                    </div>
                </div>
                
                <div class="project-stats">
                    <div class="stat">
                        <span>📝</span>
                        <span>${project.totalCommits} commits</span>
                    </div>
                    <div class="stat">
                        <span>📅</span>
                        <span>Last: ${lastActivity}</span>
                    </div>
                </div>
                
                <div class="selector-row">
                    <div class="category-selector">
                        <label for="category-${project.name}">Category:</label>
                        <select id="category-${project.name}" onchange="updateCategory('${project.name}', this.value)">
                            <option value="">Select a category...</option>
                            ${categories.map(cat => `<option value="${cat}" ${project.category === cat ? 'selected' : ''}>${cat}</option>`).join('')}
                            <option value="__new__">+ Create new category</option>
                        </select>
                        <div id="new-category-${project.name}" class="hidden" style="margin-top: 10px;">
                            <input type="text" placeholder="Enter new category name" onchange="createNewCategory('${project.name}', this.value)">
                        </div>
                    </div>
                    
                    <div class="status-selector">
                        <label for="status-${project.name}">Status:</label>
                        <select id="status-${project.name}" onchange="updateProjectStatus('${project.name}', this.value)">
                            <option value="">Select a status...</option>
                            <option value="idea" ${(project.status === 'idea' || getAnswer(project.name, 'status') === 'idea') ? 'selected' : ''}>💡 Idea - Just a spark or rough concept</option>
                            <option value="parking-lot" ${(project.status === 'parking-lot' || getAnswer(project.name, 'status') === 'parking-lot') ? 'selected' : ''}>🅿️ Parking Lot - Not in current cycle</option>
                            <option value="planning" ${(project.status === 'planning' || getAnswer(project.name, 'status') === 'planning') ? 'selected' : ''}>📝 Planning - Actively shaping into something concrete</option>
                            <option value="active" ${(project.status === 'active' || getAnswer(project.name, 'status') === 'active') ? 'selected' : ''}>🚀 Active - Currently being worked on</option>
                            <option value="paused" ${(project.status === 'paused' || getAnswer(project.name, 'status') === 'paused') ? 'selected' : ''}>⏸️ Paused - Work stopped, likely to resume later</option>
                            <option value="released" ${(project.status === 'released' || getAnswer(project.name, 'status') === 'released') ? 'selected' : ''}>🌍 Released - Publicly launched in some form</option>
                            <option value="done" ${(project.status === 'done' || getAnswer(project.name, 'status') === 'done') ? 'selected' : ''}>✅ Done/Retired - Completed or abandoned</option>
                        </select>
                    </div>
                </div>
                
                <div class="questions">
                    <div class="question">
                        <label>❤️ Heart - How excited are you about this project right now?:</label>
                        <div class="rating-bubbles" data-question="heart" data-project="${project.name}">
                            <div class="rating-bubble" data-rating="1">1</div>
                            <div class="rating-bubble" data-rating="2">2</div>
                            <div class="rating-bubble" data-rating="3">3</div>
                            <div class="rating-bubble" data-rating="4">4</div>
                            <div class="rating-bubble" data-rating="5">5</div>
                        </div>
                        <div class="rating-labels">
                            <span>Low</span>
                            <span>High</span>
                        </div>
                    </div>
                    
                    <div class="question">
                        <label>🧠 Head - How logical is it to proceed now? (timing, external factors, other people):</label>
                        <div class="rating-bubbles" data-question="head" data-project="${project.name}">
                            <div class="rating-bubble" data-rating="1">1</div>
                            <div class="rating-bubble" data-rating="2">2</div>
                            <div class="rating-bubble" data-rating="3">3</div>
                            <div class="rating-bubble" data-rating="4">4</div>
                            <div class="rating-bubble" data-rating="5">5</div>
                        </div>
                        <div class="rating-labels">
                            <span>Low</span>
                            <span>High</span>
                        </div>
                    </div>
                </div>
                
                <div class="navigation-buttons">
                    <button class="btn" onclick="previousProject()" ${currentProjectIndex === 0 ? 'disabled' : ''}>← Previous</button>
                    <button class="btn" onclick="nextProject()">${currentProjectIndex === filteredProjects.length - 1 ? 'Finish' : 'Next →'}</button>
                </div>
            `;
            
            container.classList.remove('hidden');
            
            // Set up rating bubble event listeners first
            setupRatingBubbles();
            
            // Highlight previously selected ratings with a small delay to ensure DOM is ready
            setTimeout(() => {
                highlightSelectedRatings();
            }, 100);
            
            // Now update progress indicator after everything is loaded
            // Small delay to ensure DOM is fully updated
            setTimeout(() => {
                updateProgressIndicator();
                console.log(`Project ${currentProjectIndex + 1} loaded, button state updated`);
            }, 50);
        }
        
        // Show completion message
        function showCompletionMessage() {
            // Hide project container but keep progress indicator visible
            document.getElementById('project-container').classList.add('hidden');
            
            // Check if all filtered projects have been rated
            const filteredProjects = getFilteredProjects();
            const unratedProjects = filteredProjects.filter(project => {
                const answers = userAnswers[project.name] || {};
                return !answers.head || !answers.heart;
            });
            
            if (unratedProjects.length === 0) {
                // Replace progress indicator with completion message
                const progressEl = document.getElementById('progress-indicator');
                progressEl.innerHTML = '<div class="completion-indicator">✅ All Projects Reviewed</div>';
                progressEl.classList.remove('hidden');
                
                document.getElementById('generate-plan-btn').disabled = false;
                document.getElementById('completion-message').classList.add('hidden');
                updateStatus('All projects reviewed and rated! Generate your weekly plan.');
            } else {
                // Show completion message with incomplete projects
                document.getElementById('completion-message').classList.remove('hidden');
                document.getElementById('generate-plan-btn').disabled = true;
                document.getElementById('go-back-btn').style.display = 'inline-block';
                document.getElementById('completion-status').textContent = `${unratedProjects.length} projects still need ratings. Go back and complete them.`;
                updateStatus(`All projects reviewed, but ${unratedProjects.length} still need ratings. Go back and complete them.`);
            }
        }
        
        // Go back to incomplete projects
        function goBackToIncomplete() {
            // Find first incomplete project in filtered list
            const filteredProjects = getFilteredProjects();
            for (let i = 0; i < filteredProjects.length; i++) {
                const project = filteredProjects[i];
                const answers = userAnswers[project.name] || {};
                if (!answers.head || !answers.heart) {
                    currentProjectIndex = i;
                    document.getElementById('completion-message').classList.add('hidden');
                    // Restore normal progress indicator
                    updateProgressIndicator();
                    showCurrentProject();
                    return;
                }
            }
        }
        
        // Get filtered projects based on checkbox state, sorted by heart value (highest to lowest)
        function getFilteredProjects() {
            const ignoreDone = document.getElementById('ignore-done-projects').checked;
            let filteredProjects = projectData;
            
            if (ignoreDone) {
                // Filter out projects with status 'done' or 'retired'
                filteredProjects = projectData.filter(project => {
                    const status = project.status?.toLowerCase();
                    return status !== 'done' && status !== 'retired';
                });
            }
            
            // Sort by heart value (highest to lowest)
            const sortedProjects = filteredProjects.sort((a, b) => {
                const aHeart = parseInt(userAnswers[a.name]?.heart) || 0;
                const bHeart = parseInt(userAnswers[b.name]?.heart) || 0;
                
                // Primary sort: heart value (highest first)
                if (aHeart !== bHeart) {
                    return bHeart - aHeart;
                }
                
                // Secondary sort: head value (highest first) for tie-breaking
                const aHead = parseInt(userAnswers[a.name]?.head) || 0;
                const bHead = parseInt(userAnswers[b.name]?.head) || 0;
                if (aHead !== bHead) {
                    return bHead - aHead;
                }
                
                // Tertiary sort: alphabetical for final tie-breaking
                return a.name.localeCompare(b.name);
            });
            
            // Debug logging for sorting
            if (sortedProjects.length > 0) {
                console.log('🔄 Projects sorted by heart value (highest to lowest):');
                sortedProjects.forEach((project, index) => {
                    const heart = parseInt(userAnswers[project.name]?.heart) || 0;
                    const head = parseInt(userAnswers[project.name]?.head) || 0;
                    console.log(`  ${index + 1}. ${project.name} (Heart: ${heart}, Head: ${head})`);
                });
            }
            
            return sortedProjects;
        }
        
        // Update progress indicator
        function updateProgressIndicator() {
            const progressEl = document.getElementById('progress-indicator');
            const progressTextEl = document.getElementById('progress-text');
            const filteredProjects = getFilteredProjects();
            progressTextEl.innerHTML = `Project ${currentProjectIndex + 1} of ${filteredProjects.length}`;
            progressEl.classList.remove('hidden');
            
            // Check if current project is fully rated
            const currentProject = filteredProjects[currentProjectIndex];
            if (currentProject) {
                const answers = userAnswers[currentProject.name] || {};
                const isRated = answers.head && answers.heart;
                
                // Update navigation button text
                const nextButton = document.querySelector('.navigation-buttons .btn:last-child');
                if (nextButton) {
                    if (currentProjectIndex === filteredProjects.length - 1) {
                        nextButton.textContent = isRated ? 'Finish' : 'Complete Ratings First';
                    } else {
                        nextButton.textContent = isRated ? 'Next →' : 'Rate All Questions First';
                    }
                    nextButton.disabled = !isRated;
                    
                    // Add visual feedback for button state
                    if (isRated) {
                        nextButton.style.opacity = '1';
                        nextButton.style.cursor = 'pointer';
                    } else {
                        nextButton.style.opacity = '0.6';
                        nextButton.style.cursor = 'not-allowed';
                    }
                }
            }
        }
        
        // Navigate to next project
        function nextProject() {
            const filteredProjects = getFilteredProjects();
            if (currentProjectIndex < filteredProjects.length - 1) {
                currentProjectIndex++;
                showCurrentProject();
            } else {
                showCompletionMessage();
            }
        }
        
        // Navigate to previous project
        function previousProject() {
            if (currentProjectIndex > 0) {
                currentProjectIndex--;
                showCurrentProject();
            }
        }
        
        // Force refresh button state (useful for debugging)
        function refreshButtonState() {
            updateProgressIndicator();
        }
        
        // Set up rating bubble event listeners
        function setupRatingBubbles() {
            const ratingBubbles = document.querySelectorAll('.rating-bubble');
            ratingBubbles.forEach(bubble => {
                bubble.addEventListener('click', function() {
                    const rating = this.dataset.rating;
                    const question = this.parentElement.dataset.question;
                    const project = this.parentElement.dataset.project;
                    
                    // Remove selected class from all bubbles in this group
                    this.parentElement.querySelectorAll('.rating-bubble').forEach(b => b.classList.remove('selected'));
                    
                    // Add selected class to clicked bubble
                    this.classList.add('selected');
                    
                    // Update answer
                    updateAnswer(project, question, rating);
                    
                    // Update button state after rating change
                    setTimeout(() => updateProgressIndicator(), 100);
                });
            });
        }
        
        // Highlight previously selected ratings
        function highlightSelectedRatings() {
            const filteredProjects = getFilteredProjects();
            const currentProject = filteredProjects[currentProjectIndex];
            
            if (!currentProject) {
                console.log('❌ No current project for highlighting ratings');
                return;
            }
            
            console.log(`🎯 Highlighting ratings for project: ${currentProject.name}`);
            console.log(`🎯 Current project index: ${currentProjectIndex}`);
            console.log(`🎯 Filtered projects length: ${filteredProjects.length}`);
            
            ['head', 'heart'].forEach(question => {
                const answer = getAnswer(currentProject.name, question);
                console.log(`🔍 Looking for ${question} rating: ${answer}`);
                
                if (answer) {
                    const bubble = document.querySelector(`[data-question="${question}"][data-project="${currentProject.name}"] .rating-bubble[data-rating="${answer}"]`);
                    console.log(`🔍 Found bubble for ${question}:`, bubble);
                    
                    if (bubble) {
                        bubble.classList.add('selected');
                        console.log(`✅ Added 'selected' class to ${question} rating ${answer}`);
                    } else {
                        console.log(`❌ No bubble found for ${question} rating ${answer}`);
                        console.log(`🔍 Selector used: [data-question="${question}"][data-project="${currentProject.name}"] .rating-bubble[data-rating="${answer}"]`);
                    }
                } else {
                    console.log(`❌ No answer found for ${question}`);
                }
            });
        }
        
        // Get project color
        function getProjectColor(projectName) {
            const colorData = projectColors[projectName];
            if (colorData && colorData.hex) {
                const category = colorData.category || 'Unknown Category';
                return `<div class="color-square" style="background-color: ${colorData.hex};" title="${projectName} (${category})"></div>`;
            }
            return `<div class="color-square" style="background-color: #3498db;" title="${projectName} (Unknown Category)"></div>`;
        }
        
        // Get status display with emoji
        function getStatusDisplay(status) {
            const statusMap = {
                'idea': '💡 Idea - Just a spark or rough concept',
                'parking-lot': '🅿️ Parking Lot - Not in current cycle',
                'planning': '📝 Planning - Actively shaping into something concrete',
                'active': '🚀 Active - Currently being worked on',
                'paused': '⏸️ Paused - Work stopped, likely to resume later',
                'released': '🌍 Released - Publicly launched in some form',
                'done': '✅ Done/Retired - Completed or abandoned'
            };
            return statusMap[status] || status;
        }
        
        // Update category
        function updateCategory(projectName, category) {
            if (category === '__new__') {
                document.getElementById(`new-category-${projectName}`).classList.remove('hidden');
                return;
            }
            
            document.getElementById(`new-category-${projectName}`).classList.add('hidden');
            
            const project = projectData.find(p => p.name === projectName);
            if (project) {
                project.category = category;
                if (!categories.includes(category)) {
                    categories.push(category);
                }
                
                // Also save category in userAnswers for persistence
                if (!userAnswers[projectName]) {
                    userAnswers[projectName] = {};
                }
                userAnswers[projectName].category = category;
                
                saveData();
            }
        }
        
        // Update project status
        function updateProjectStatus(projectName, status) {
            console.log(`🔄 === UPDATE STATUS FUNCTION CALLED ===`);
            console.log(`🔄 Parameters: projectName="${projectName}", status="${status}"`);
            console.log(`🔄 projectData length: ${projectData.length}`);
            console.log(`🔄 userAnswers keys:`, Object.keys(userAnswers));
            
            const project = projectData.find(p => p.name === projectName);
            console.log(`🔄 Found project:`, project);
            
            if (project) {
                console.log(`🔄 Before update - project.status: ${project.status}`);
                project.status = status;
                console.log(`✅ After update - project.status: ${project.status}`);
                
                // Also save status in userAnswers for persistence
                if (!userAnswers[projectName]) {
                    userAnswers[projectName] = {};
                    console.log(`🔄 Created new userAnswers entry for ${projectName}`);
                }
                console.log(`🔄 Before update - userAnswers[${projectName}]:`, userAnswers[projectName]);
                userAnswers[projectName].status = status;
                console.log(`✅ After update - userAnswers[${projectName}]:`, userAnswers[projectName]);
                
                console.log(`🔄 About to call saveData()...`);
                saveData();
                console.log(`💾 Called saveData() for status update`);
                
                // Verify the update worked
                console.log(`🔄 Verification - project.status: ${project.status}`);
                console.log(`🔄 Verification - userAnswers[${projectName}].status: ${userAnswers[projectName].status}`);
            } else {
                console.error(`❌ Project ${projectName} not found in projectData`);
                console.error(`❌ Available projects:`, projectData.map(p => p.name));
            }
        }
        
        // Create new category
        function createNewCategory(projectName, categoryName) {
            if (categoryName.trim()) {
                const newCategory = categoryName.trim();
                categories.push(newCategory);
                
                // Update the project's category
                const project = projectData.find(p => p.name === projectName);
                if (project) {
                    project.category = newCategory;
                }
                
                // Save in userAnswers for persistence
                if (!userAnswers[projectName]) {
                    userAnswers[projectName] = {};
                }
                userAnswers[projectName].category = newCategory;
                
                // Update category selector
                const selector = document.getElementById(`category-${projectName}`);
                if (selector) {
                    selector.innerHTML = `
                        <option value="">Select a category...</option>
                        ${categories.map(cat => `<option value="${cat}" ${cat === newCategory ? 'selected' : ''}>${cat}</option>`).join('')}
                        <option value="__new__">+ Create new category</option>
                    `;
                }
                
                // Hide the new category input
                document.getElementById(`new-category-${projectName}`).classList.add('hidden');
                
                // Save all data
                saveData();
            }
        }
        
        // Update user answer
        function updateAnswer(projectName, question, answer) {
            if (!userAnswers[projectName]) {
                userAnswers[projectName] = {};
            }
            userAnswers[projectName][question] = answer;
            saveData();
        }
        
        // Get user answer
        function getAnswer(projectName, question) {
            const answer = userAnswers[projectName]?.[question] || '';
            console.log(`🔍 getAnswer(${projectName}, ${question}):`, answer);
            return answer;
        }
        
        
        // Test function to verify sorting logic
        function testSortingLogic() {
            console.log('🧪 Testing sorting logic...');
            
            const testProjects = [
                { name: 'Project A', priorityScore: 8, status: 'planning' },
                { name: 'Project B', priorityScore: 8, status: 'active' },
                { name: 'Project C', priorityScore: 7, status: 'active' },
                { name: 'Project D', priorityScore: 8, status: 'planning' },
                { name: 'Project E', priorityScore: 6, status: 'unknown' },
                { name: 'Project F', priorityScore: 8, status: 'active' }
            ];
            
            console.log('📊 Before sorting:', testProjects.map(p => `${p.name}: ${p.priorityScore} (${p.status})`));
            
            const sorted = sortProjectsByPriority(testProjects);
            
            console.log('📊 After sorting:', sorted.map(p => `${p.name}: ${p.priorityScore} (${p.status})`));
            
            // Verify sorting order
            const expectedOrder = ['Project B', 'Project F', 'Project A', 'Project D', 'Project C', 'Project E'];
            const actualOrder = sorted.map(p => p.name);
            
            if (JSON.stringify(expectedOrder) === JSON.stringify(actualOrder)) {
                console.log('✅ Sorting test passed!');
            } else {
                console.log('❌ Sorting test failed!');
                console.log('Expected:', expectedOrder);
                console.log('Actual:', actualOrder);
            }
            
            // Test edge cases
            console.log('🧪 Testing edge cases...');
            
            // Test empty array
            const emptyResult = sortProjectsByPriority([]);
            console.log('Empty array test:', emptyResult.length === 0 ? '✅' : '❌');
            
            // Test null/undefined
            const nullResult = sortProjectsByPriority(null);
            console.log('Null test:', nullResult === null ? '✅' : '❌');
            
            // Test invalid projects
            const invalidProjects = [
                { name: 'Valid Project', priorityScore: 5, status: 'active' },
                { name: '', priorityScore: 8, status: 'planning' }, // Invalid name
                { priorityScore: 6, status: 'unknown' }, // Missing name
                { name: 'Another Project', status: 'active' }, // Missing priorityScore
                { name: 'Last Project', priorityScore: 'invalid', status: 'planning' } // Invalid priorityScore
            ];
            
            const edgeCaseResult = sortProjectsByPriority(invalidProjects);
            console.log('Edge case test:', edgeCaseResult.length === 1 ? '✅' : '❌', `(filtered ${invalidProjects.length - edgeCaseResult.length} invalid projects)`);
        }
        
        // Generate weekly plan with priority scoring and intelligent recommendations
        function generateWeeklyPlan() {
            console.log('🔄 Starting weekly plan generation...');
            console.log('📊 Project data:', projectData);
            console.log('💭 User answers:', userAnswers);
            
            // Check if all projects have been rated
            const unratedProjects = projectData.filter(project => {
                const answers = userAnswers[project.name] || {};
                return !answers.head || !answers.heart;
            });
            
            if (unratedProjects.length > 0) {
                const projectNames = unratedProjects.map(p => p.name).join(', ');
                showError(`Please rate all projects before generating plan. Missing ratings for: ${projectNames}`);
                return;
            }
            
            const planContent = document.getElementById('plan-content');
            
            // Calculate enhanced priority scores with tie-breaking factors
            const projectsWithScores = projectData.map(project => {
                const answers = userAnswers[project.name] || {};
                const headScore = parseInt(answers.head) || 0;
                const heartScore = parseInt(answers.heart) || 0;
                const basePriorityScore = headScore + heartScore;
                
                // Tie-breaking factors
                let tieBreakBonus = 0;
                const tieBreakFactors = [];
                
                // Status bonus: active projects get priority
                if (project.status === 'active') {
                    tieBreakBonus += 1.0;
                    tieBreakFactors.push({ factor: 'Active Status', bonus: 1.0 });
                } else if (project.status === 'planning') {
                    tieBreakBonus += 0.5;
                    tieBreakFactors.push({ factor: 'Planning Status', bonus: 0.5 });
                }
                
                // Recency bonus: projects updated recently get small boost
                if (project.lastUpdated) {
                    const daysSinceUpdate = (Date.now() - new Date(project.lastUpdated).getTime()) / (1000 * 60 * 60 * 24);
                    if (daysSinceUpdate <= 7) {
                        tieBreakBonus += 0.5;
                        tieBreakFactors.push({ factor: 'Updated within week', bonus: 0.5 });
                    } else if (daysSinceUpdate <= 30) {
                        tieBreakBonus += 0.2;
                        tieBreakFactors.push({ factor: 'Updated within month', bonus: 0.2 });
                    }
                }
                
                // Category balance: projects from underrepresented categories get small boost
                const categoryCount = projectData.filter(p => p.category === project.category).length;
                if (categoryCount <= 2) {
                    tieBreakBonus += 0.3;
                    tieBreakFactors.push({ factor: 'Small category boost', bonus: 0.3 });
                }
                
                // Progress bonus: projects with recent activity get small boost
                if (project.commitCount && project.commitCount > 0) {
                    tieBreakBonus += 0.2;
                    tieBreakFactors.push({ factor: 'Has commits', bonus: 0.2 });
                }
                
                const enhancedPriorityScore = basePriorityScore + tieBreakBonus;
                
                return {
                    ...project,
                    headScore,
                    heartScore,
                    basePriorityScore,
                    tieBreakBonus: parseFloat(tieBreakBonus.toFixed(2)),
                    tieBreakFactors,
                    priorityScore: parseFloat(enhancedPriorityScore.toFixed(2)),
                    category: project.category || 'Uncategorized',
                    status: project.status || 'unknown'
                };
            });
            
            // Group projects by category with priority analysis
            const projectsByCategory = {};
            const categoryStats = {};
            
            projectsWithScores.forEach(project => {
                const category = project.category;
                if (!projectsByCategory[category]) {
                    projectsByCategory[category] = [];
                    categoryStats[category] = {
                        totalPriority: 0,
                        projectCount: 0,
                        highPriorityCount: 0, // Priority 8-10
                        mediumPriorityCount: 0, // Priority 5-7
                        activeProjects: 0,
                        avgPriority: 0
                    };
                }
                
                projectsByCategory[category].push(project);
                categoryStats[category].totalPriority += project.priorityScore;
                categoryStats[category].projectCount += 1;
                
                if (project.priorityScore >= 8) categoryStats[category].highPriorityCount += 1;
                else if (project.priorityScore >= 5) categoryStats[category].mediumPriorityCount += 1;
                
                if (project.status === 'active') categoryStats[category].activeProjects += 1;
            });
            
            // Calculate average priorities and determine focus category
            Object.keys(categoryStats).forEach(category => {
                categoryStats[category].avgPriority = categoryStats[category].totalPriority / categoryStats[category].projectCount;
            });
            
            // Select focus category based on weighted algorithm
            const focusCategory = selectFocusCategory(categoryStats);
            
            // Generate project recommendations
            const recommendations = generateProjectRecommendations(projectsWithScores, focusCategory);
            
            // Validate recommendations before proceeding
            if (!recommendations || !recommendations.mainFocus || !recommendations.sideFocus || !recommendations.tangent) {
                showError('Failed to generate project recommendations. Please check your project data.');
                return;
            }
            
            // Build the enhanced plan HTML
            let planHTML = `
                <div class="plan-summary">
                    <h3>🎯 Weekly Focus Strategy</h3>
                    <div class="focus-category">
                        <h4>Primary Focus Category: <span class="highlight">${focusCategory}</span></h4>
                        <p>Selected based on highest priority projects and active development status</p>
                    </div>
                    
                    <div class="project-recommendations">
                        <h4>🚀 Recommended Projects for This Week</h4>
                        
                        <div class="recommendation main-focus full-width">
                            <h5>🎯 Main Focus: ${recommendations.mainFocus.name}</h5>
                            <div class="scoring-breakdown">
                                <p><strong>Priority Score: ${recommendations.mainFocus.priorityScore}/10</strong> | Status: ${getStatusDisplay(recommendations.mainFocus.status)}</p>
                                <p class="base-calculation">Base: ${recommendations.mainFocus.headScore}/5 Head + ${recommendations.mainFocus.heartScore}/5 Heart = ${recommendations.mainFocus.basePriorityScore}/10</p>
                                ${recommendations.mainFocus.tieBreakBonus > 0 ? `<p class="tie-break-calculation">Tie-break bonus: <span class="tie-break-tooltip" data-factors='${JSON.stringify(recommendations.mainFocus.tieBreakFactors)}'>+${recommendations.mainFocus.tieBreakBonus}</span> → <strong>${recommendations.mainFocus.priorityScore}/10</strong></p>` : ''}
                            </div>
                            <p class="focus-note">Active or planning projects only - ready for immediate work</p>
                        </div>
                        
                        <div class="recommendation side-focus">
                            <h5>⚡ Side Focus: ${recommendations.sideFocus.name}</h5>
                            <div class="scoring-breakdown">
                                <p><strong>Priority Score: ${recommendations.sideFocus.priorityScore}/10</strong> | Status: ${getStatusDisplay(recommendations.sideFocus.status)}</p>
                                <p class="base-calculation">Base: ${recommendations.sideFocus.headScore}/5 Head + ${recommendations.sideFocus.heartScore}/5 Heart = ${recommendations.sideFocus.basePriorityScore}/10</p>
                                ${recommendations.sideFocus.tieBreakBonus > 0 ? `<p class="tie-break-calculation">Tie-break bonus: <span class="tie-break-tooltip" data-factors='${JSON.stringify(recommendations.sideFocus.tieBreakFactors)}'>+${recommendations.sideFocus.tieBreakBonus}</span> → <strong>${recommendations.sideFocus.priorityScore}/10</strong></p>` : ''}
                            </div>
                            <p class="focus-note">Active or planning projects only - secondary priority</p>
                        </div>
                        
                        <div class="recommendation tangent">
                            <h5>🌟 Tangent Project: ${recommendations.tangent.name}</h5>
                            <div class="scoring-breakdown">
                                <p><strong>Priority Score: ${recommendations.tangent.priorityScore}/10</strong> | Status: ${getStatusDisplay(recommendations.tangent.status)}</p>
                                <p class="base-calculation">Base: ${recommendations.tangent.headScore}/5 Head + ${recommendations.tangent.heartScore}/5 Heart = ${recommendations.tangent.basePriorityScore}/10</p>
                                ${recommendations.tangent.tieBreakBonus > 0 ? `<p class="tie-break-calculation">Tie-break bonus: <span class="tie-break-tooltip" data-factors='${JSON.stringify(recommendations.tangent.tieBreakFactors)}'>+${recommendations.tangent.tieBreakBonus}</span> → <strong>${recommendations.tangent.priorityScore}/10</strong></p>` : ''}
                            </div>
                            <p class="tangent-note">High interest project to explore when you have spare time</p>
                        </div>
                    </div>
                </div>
                
                <div class="category-breakdown">
                    <h3>📊 Category Breakdown & Priority Analysis</h3>
            `;
            
            // Sort categories by average priority
            const sortedCategories = Object.entries(categoryStats).sort((a, b) => b[1].avgPriority - a[1].avgPriority);
            
            sortedCategories.forEach(([category, stats]) => {
                const isFocusCategory = category === focusCategory;
                const projects = projectsByCategory[category];
                
                planHTML += `
                    <div class="plan-category ${isFocusCategory ? 'focus-category' : ''}">
                        <h4>${category} ${isFocusCategory ? '🎯' : ''}</h4>
                        <div class="category-stats">
                            <span class="stat">📈 Avg Priority: ${stats.avgPriority.toFixed(1)}/10</span>
                            <span class="stat">🔢 Projects: ${stats.projectCount}</span>
                            <span class="stat">⭐ High Priority: ${stats.highPriorityCount}</span>
                            <span class="stat">🔄 Active: ${stats.activeProjects}</span>
                        </div>
                        
                        ${sortProjectsByPriority(projects).map(project => `
                            <div class="plan-project priority-${Math.floor(project.priorityScore / 2)}">
                                <h5>${getProjectColor(project.name)} ${project.name}</h5>
                                <div class="project-scores">
                                    <span class="priority-score">Priority: ${project.priorityScore}/10</span>
                                    <span class="base-score">Base: ${project.basePriorityScore}/10</span>
                                    ${project.tieBreakBonus > 0 ? `<span class="tie-break-badge tie-break-tooltip" data-factors='${JSON.stringify(project.tieBreakFactors)}'>+${project.tieBreakBonus}</span>` : ''}
                                    <span class="head-score">Head: ${project.headScore}/5</span>
                                    <span class="heart-score">Heart: ${project.heartScore}/5</span>
                                    <span class="status-badge status-${project.status}">${getStatusDisplay(project.status)}</span>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
            });
            
            planHTML += '</div>';
            
            planContent.innerHTML = planHTML;
            document.getElementById('weekly-plan').classList.remove('hidden');
            document.getElementById('save-plan-btn').disabled = false;
            document.getElementById('sync-notion-btn').disabled = false;
            document.getElementById('sync-notion-btn').querySelector('.sync-text').textContent = '🔄 Sync to Notion';
            
            // Set up tooltips for tiebreaker bonuses
            setupTiebreakTooltips();
            
            // Show focus input section if no focus has been saved yet
            console.log('🔍 weeklyFocus object:', weeklyFocus);
            console.log('🔍 primary focus:', weeklyFocus.primary);
            console.log('🔍 tangent focus:', weeklyFocus.tangent);
            console.log('🔍 primary focus truthy:', !!weeklyFocus.primary);
            console.log('🔍 tangent focus truthy:', !!weeklyFocus.tangent);
            
            if (!weeklyFocus.primary && !weeklyFocus.tangent) {
                console.log('🔍 Showing focus input section - no focus saved yet');
                const focusInputSection = document.getElementById('focus-input-section');
                if (focusInputSection) {
                    focusInputSection.classList.remove('hidden');
                    console.log('🔍 Focus input section shown successfully');
                } else {
                    console.error('❌ focus-input-section element not found');
                }
            } else {
                console.log('🔍 Showing saved focus display - focus already exists');
                // Show saved focus display
                showSavedFocus();
            }
            
            updateStatus('Strategic weekly plan generated! Review priorities and focus areas.');
        }
        
        // Show saved focus display
        function showSavedFocus() {
            document.getElementById('saved-primary-focus').textContent = weeklyFocus.primary || 'Not set';
            document.getElementById('saved-tangent-focus').textContent = weeklyFocus.tangent || 'Not set';
            document.getElementById('saved-focus-display').classList.remove('hidden');
            document.getElementById('focus-input-section').classList.add('hidden');
        }
        
        // Save focus data
        function saveFocus() {
            const primaryFocus = document.getElementById('primary-focus').value.trim();
            const tangentFocus = document.getElementById('tangent-focus').value.trim();
            
            if (!primaryFocus && !tangentFocus) {
                showError('Please enter at least one focus before saving.');
                return;
            }
            
            weeklyFocus.primary = primaryFocus;
            weeklyFocus.tangent = tangentFocus;
            
            saveData();
            showSavedFocus();
            updateStatus('✅ Weekly focus saved successfully!');
        }
        
        // Skip focus input
        function skipFocus() {
            document.getElementById('focus-input-section').classList.add('hidden');
            updateStatus('Focus input skipped. You can edit it later.');
        }
        
        // Edit focus
        function editFocus() {
            document.getElementById('primary-focus').value = weeklyFocus.primary;
            document.getElementById('tangent-focus').value = weeklyFocus.tangent;
            document.getElementById('saved-focus-display').classList.add('hidden');
            document.getElementById('focus-input-section').classList.remove('hidden');
        }
        
        // Select focus category using weighted algorithm
        function selectFocusCategory(categoryStats) {
            const categories = Object.entries(categoryStats);
            
            // Calculate weighted scores for each category
            const weightedScores = categories.map(([category, stats]) => {
                // Weight factors: high priority projects (40%), average priority (30%), active projects (20%), total projects (10%)
                const highPriorityWeight = (stats.highPriorityCount / Math.max(...categories.map(c => c[1].highPriorityCount))) * 0.4;
                const avgPriorityWeight = (stats.avgPriority / Math.max(...categories.map(c => c[1].avgPriority))) * 0.3;
                const activeWeight = (stats.activeProjects / Math.max(...categories.map(c => c[1].activeProjects))) * 0.2;
                const projectCountWeight = (stats.projectCount / Math.max(...categories.map(c => c[1].projectCount))) * 0.1;
                
                return {
                    category,
                    weightedScore: highPriorityWeight + avgPriorityWeight + activeWeight + projectCountWeight
                };
            });
            
            // Return category with highest weighted score
            return weightedScores.sort((a, b) => b.weightedScore - a.weightedScore)[0].category;
        }
        
        // Generate project recommendations
        function generateProjectRecommendations(projectsWithScores, focusCategory) {
            // Ensure we have projects to work with
            if (!projectsWithScores || projectsWithScores.length === 0) {
                return {
                    mainFocus: { name: 'No projects available', priorityScore: 0, status: 'unknown', headScore: 0, heartScore: 0, basePriorityScore: 0, tieBreakFactors: [] },
                    sideFocus: { name: 'No projects available', priorityScore: 0, status: 'unknown', headScore: 0, heartScore: 0, basePriorityScore: 0, tieBreakFactors: [] },
                    tangent: { name: 'No projects available', priorityScore: 0, status: 'unknown', headScore: 0, heartScore: 0, basePriorityScore: 0, tieBreakFactors: [] }
                };
            }
            
            // Helper function to find next best project excluding already selected ones
            const findNextBestProject = (candidates, excludeProjects, sortBy = 'priorityScore') => {
                const available = candidates.filter(p => !excludeProjects.some(exclude => exclude.name === p.name));
                if (available.length === 0) return null;
                
                if (sortBy === 'priorityScore') {
                    return sortProjectsByPriority(available)[0];
                } else if (sortBy === 'heartScore') {
                    return available.sort((a, b) => b.heartScore - a.heartScore)[0];
                }
                return available[0];
            };
            
            // Track selected projects to avoid duplicates
            const selectedProjects = [];
            
            // Define status categories for filtering
            const actionableStatuses = ['active', 'planning']; // Projects that can be actively worked on
            const ideationStatuses = ['planning', 'unknown']; // Projects suitable for tangents
            const excludedStatuses = ['done', 'released', 'abandoned']; // Projects to exclude from main focus
            
            // Main focus: highest priority project from focus category (only actionable projects)
            const focusCategoryProjects = projectsWithScores.filter(p => 
                p.category === focusCategory && 
                actionableStatuses.includes(p.status)
            );
            let mainFocus = sortProjectsByPriority(focusCategoryProjects)[0];
            
            // Fallback if no actionable projects in focus category - look for any actionable project
            if (!mainFocus) {
                const actionableProjects = projectsWithScores.filter(p => actionableStatuses.includes(p.status));
                mainFocus = sortProjectsByPriority(actionableProjects)[0];
            }
            
            if (mainFocus) {
                selectedProjects.push(mainFocus);
            }
            
            // Side focus: second highest priority actionable project, excluding main focus
            let sideFocus = null;
            if (mainFocus) {
                // First try to find another actionable project from focus category
                sideFocus = findNextBestProject(focusCategoryProjects, selectedProjects, 'priorityScore');
                
                // If none in focus category, look in other categories
                if (!sideFocus) {
                    const otherCategoriesActionable = projectsWithScores.filter(p => 
                        p.category !== focusCategory && 
                        actionableStatuses.includes(p.status)
                    );
                    sideFocus = findNextBestProject(otherCategoriesActionable, selectedProjects, 'priorityScore');
                }
                
                // Final fallback: any actionable project not yet selected
                if (!sideFocus) {
                    const allActionable = projectsWithScores.filter(p => actionableStatuses.includes(p.status));
                    sideFocus = findNextBestProject(allActionable, selectedProjects, 'priorityScore');
                }
            }
            
            if (sideFocus) {
                selectedProjects.push(sideFocus);
            }
            
            // Tangent: high interest project with ideation status (planning/unknown), excluding already selected
            let tangent = null;
            const tangentCandidates = projectsWithScores.filter(p => 
                p.heartScore >= 4 && 
                ideationStatuses.includes(p.status) &&
                !excludedStatuses.includes(p.status)
            );
            
            if (tangentCandidates.length > 0) {
                tangent = findNextBestProject(tangentCandidates, selectedProjects, 'heartScore');
            }
            
            if (!tangent) {
                // Fallback: find any high heart score project that's not excluded, excluding selected
                const highHeartIdeation = projectsWithScores.filter(p => 
                    p.heartScore >= 4 && 
                    !excludedStatuses.includes(p.status)
                );
                tangent = findNextBestProject(highHeartIdeation, selectedProjects, 'heartScore');
            }
            
            if (!tangent) {
                // Final fallback: pick any ideation project not already selected and not excluded
                const availableIdeation = projectsWithScores.filter(p => 
                    !excludedStatuses.includes(p.status) &&
                    !selectedProjects.some(selected => selected.name === p.name)
                );
                tangent = availableIdeation[0] || null;
            }
            
            // Ensure all recommendations have valid data
            const ensureValidProject = (project, fallbackName) => {
                if (!project) {
                    return { name: fallbackName, priorityScore: 0, status: 'unknown', headScore: 0, heartScore: 0, basePriorityScore: 0, tieBreakFactors: [] };
                }
                return {
                    name: project.name || fallbackName,
                    priorityScore: project.priorityScore || 0,
                    status: project.status || 'unknown',
                    headScore: project.headScore || 0,
                    heartScore: project.heartScore || 0,
                    basePriorityScore: project.basePriorityScore || 0,
                    tieBreakFactors: project.tieBreakFactors || []
                };
            };
            
            return {
                mainFocus: ensureValidProject(mainFocus, 'Main Focus Project'),
                sideFocus: ensureValidProject(sideFocus, 'Side Focus Project'),
                tangent: ensureValidProject(tangent, 'Tangent Project')
            };
        }
        
        // Save weekly plan
        async function saveWeeklyPlan() {
            try {
                const weekStart = new Date().toISOString().split('T')[0]; // Use UTC date for consistency
                const planData = {
                    projects: projectData,
                    userAnswers,
                    categories,
                    weeklyFocus,
                    generatedAt: new Date().toISOString()
                };
                
                const response = await fetch('/api/weekly-plan', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ planData, weekStart })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                
                if (result.success) {
                    updateStatus(`✅ Plan saved successfully! ID: ${result.planId}`);
                    document.getElementById('save-plan-btn').classList.add('success');
                    document.getElementById('save-plan-btn').textContent = '✅ Saved!';
                    setTimeout(() => {
                        document.getElementById('save-plan-btn').classList.remove('success');
                        document.getElementById('save-plan-btn').textContent = '💾 Save Plan';
                    }, 2000);
                } else {
                    throw new Error(result.error || 'Failed to save plan');
                }
                
            } catch (error) {
                console.error('Error saving weekly plan:', error);
                showError(`Failed to save plan: ${error.message}`);
            }
        }
        
        // Sync weekly plan to Notion
        async function syncToNotion() {
            const syncBtn = document.getElementById('sync-notion-btn');
            const syncText = syncBtn.querySelector('.sync-text');
            
            try {
                // Start spinning animation
                console.log('🔄 Adding spinning class to button');
                syncBtn.classList.add('spinning');
                console.log('🔄 Button classes after adding spinning:', syncBtn.className);
                syncBtn.disabled = true;
                updateStatus('🔄 Syncing to Notion...');
                
                const weekStart = new Date().toISOString().split('T')[0]; // Use UTC date for consistency
                const planData = {
                    projects: projectData,
                    userAnswers,
                    categories,
                    weeklyFocus,
                    generatedAt: new Date().toISOString()
                };
                
                const response = await fetch('/api/weekly-plan/sync-notion', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ planData, weekStart })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                
                if (result.success) {
                    updateStatus(`✅ Synced ${result.summary.success} projects to Notion! ${result.summary.errors > 0 ? `${result.summary.errors} errors.` : ''}`);
                    console.log('🔄 Removing spinning class from button');
                    syncBtn.classList.remove('spinning');
                    console.log('🔄 Button classes after removing spinning:', syncBtn.className);
                    syncBtn.classList.add('success');
                    syncText.textContent = '✅ Synced!';
                    setTimeout(() => {
                        syncBtn.classList.remove('success');
                        syncText.textContent = '🔄 Sync to Notion';
                        syncBtn.disabled = false;
                    }, 3000);
                } else {
                    throw new Error(result.error || 'Failed to sync to Notion');
                }
                
            } catch (error) {
                console.error('Error syncing to Notion:', error);
                showError(`Failed to sync to Notion: ${error.message}`);
                // Stop spinning and restore button
                syncBtn.classList.remove('spinning');
                syncBtn.disabled = false;
            }
        }
        
        // Load previous plans
        async function loadPreviousPlans() {
            try {
                const response = await fetch('/api/weekly-plans');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                
                if (result.success && result.plans.length > 0) {
                    // Show plans in a modal or expand the weekly plan section
                    const planContent = document.getElementById('plan-content');
                    let plansHTML = '<h3 style="margin-bottom: 20px;">Previous Weekly Plans</h3>';
                    
                    result.plans.reverse().forEach(plan => {
                        const planDate = new Date(plan.weekStart).toLocaleDateString();
                        const createdDate = new Date(plan.createdAt).toLocaleDateString();
                        const focus = plan.planData.weeklyFocus || {};
                        
                        plansHTML += `
                            <div class="plan-category" style="margin-bottom: 20px;">
                                <h4>Week of ${planDate} (Created: ${createdDate})</h4>
                                <div style="font-size: 14px; color: #7f8c8d; margin-bottom: 10px;">
                                    Plan ID: ${plan.id}
                                </div>
                                
                                ${(focus.primary || focus.tangent) ? `
                                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                        <h5 style="margin: 0 0 10px 0;">🎯 Weekly Focus</h5>
                                        ${focus.primary ? `<div style="margin-bottom: 8px;"><strong>🎯 Primary:</strong> ${focus.primary}</div>` : ''}
                                        ${focus.tangent ? `<div><strong>🌟 Tangent:</strong> ${focus.tangent}</div>` : ''}
                                    </div>
                                ` : ''}
                                
                                <div style="max-height: 300px; overflow-y: auto; border: 1px solid #ddd; border-radius: 6px; padding: 15px; background: #f8f9fa;">
                                    <pre style="white-space: pre-wrap; font-family: inherit; margin: 0;">${JSON.stringify(plan.planData, null, 2)}</pre>
                                </div>
                            </div>
                        `;
                    });
                    
                    planContent.innerHTML = plansHTML;
                    document.getElementById('weekly-plan').classList.remove('hidden');
                    updateStatus(`Loaded ${result.plans.length} previous plans`);
                } else {
                    updateStatus('No previous plans found');
                }
                
            } catch (error) {
                console.error('Error loading previous plans:', error);
                showError(`Failed to load previous plans: ${error.message}`);
            }
        }
        
        // Utility functions
        function showLoading(show) {
            document.getElementById('loading').classList.toggle('hidden', !show);
        }
        
        function showError(message) {
            const errorEl = document.getElementById('error');
            errorEl.textContent = message;
            errorEl.classList.remove('hidden');
        }
        
        function hideError() {
            document.getElementById('error').classList.add('hidden');
        }
        
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }
        
        // Set up tooltips for tiebreaker bonuses
        function setupTiebreakTooltips() {
            const tooltips = document.querySelectorAll('.tie-break-tooltip');
            tooltips.forEach(tooltip => {
                const factors = JSON.parse(tooltip.dataset.factors || '[]');
                if (factors.length > 0) {
                    const tooltipText = factors.map(f => `${f.factor}: +${f.bonus}`).join('\n');
                    tooltip.setAttribute('data-tooltip', tooltipText);
                }
            });
        }
        
        // Event listeners
        document.getElementById('refresh-btn').addEventListener('click', loadWeeklyData);
        document.getElementById('generate-plan-btn').addEventListener('click', generateWeeklyPlan);
        document.getElementById('save-plan-btn').addEventListener('click', saveWeeklyPlan);
        document.getElementById('sync-notion-btn').addEventListener('click', syncToNotion);
        document.getElementById('load-plans-btn').addEventListener('click', loadPreviousPlans);
        
        // Checkbox event listener
        document.getElementById('ignore-done-projects').addEventListener('change', function() {
            // Save checkbox state to localStorage
            localStorage.setItem('ignoreDoneProjects', this.checked);
            
            // Reset to first project and refresh view
            currentProjectIndex = 0;
            showCurrentProject();
        });
        
        // Focus input event listeners
        document.getElementById('save-focus-btn').addEventListener('click', saveFocus);
        document.getElementById('skip-focus-btn').addEventListener('click', skipFocus);
        document.getElementById('edit-focus-btn').addEventListener('click', editFocus);
        
        // Load data when page loads
        document.addEventListener('DOMContentLoaded', () => {
            loadSavedData(); // Load saved data first
            loadWeeklyData(); // Then load project data
        });
    </script>

    <!-- Color Customizer Modal -->
    <div id="color-customizer-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h2>🎨 Customize Category Colors</h2>
                <span class="close" onclick="closeColorCustomizer()">&times;</span>
            </div>
            <div class="modal-body">
                <p>Customize the color palette for each project category. Colors will be automatically assigned to projects within each category.</p>
                <div id="category-colors-container">
                    <!-- Category colors will be loaded here -->
                </div>
                <div class="modal-actions">
                    <button id="reset-colors-btn" class="btn btn-secondary">🔄 Reset to Defaults</button>
                    <button id="save-colors-btn" class="btn btn-primary">💾 Save Changes</button>
                </div>
            </div>
        </div>
    </div>

    <style>
        .modal {
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 0;
            border-radius: 12px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .modal-header {
            padding: 20px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 12px 12px 0 0;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 1.5em;
        }

        .close {
            color: white;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }

        .close:hover {
            opacity: 0.7;
        }

        .modal-body {
            padding: 20px;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
        }

        .category-color-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 15px;
            margin: 10px 0;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }

        .category-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .category-color-preview {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: 2px solid rgba(0,0,0,0.1);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .category-name {
            font-weight: 600;
            color: #333;
        }

        .category-count {
            color: #666;
            font-size: 0.9em;
        }

        .color-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .color-input {
            width: 60px;
            height: 40px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
        }

        .generate-palette-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
        }

        .generate-palette-btn:hover {
            background: #5a6fd8;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-primary {
            background: #007bff;
            color: white;
        }

        .btn-primary:hover {
            background: #0056b3;
        }
    </style>

    <script>
        let colorCustomizerData = {};

        function openColorCustomizer() {
            loadColorCustomizerData();
            document.getElementById('color-customizer-modal').style.display = 'flex';
        }

        function closeColorCustomizer() {
            document.getElementById('color-customizer-modal').style.display = 'none';
        }

        async function loadColorCustomizerData() {
            try {
                const response = await fetch('/api/color-palette/stats');
                if (response.ok) {
                    const data = await response.json();
                    colorCustomizerData = data.stats;
                    renderCategoryColors();
                } else {
                    console.error('Failed to load color data');
                }
            } catch (error) {
                console.error('Error loading color data:', error);
            }
        }

        function renderCategoryColors() {
            const container = document.getElementById('category-colors-container');
            container.innerHTML = '';

            if (!colorCustomizerData.categoryBreakdown) {
                container.innerHTML = '<p>No category data available.</p>';
                return;
            }

            Object.entries(colorCustomizerData.categoryBreakdown).forEach(([category, count]) => {
                const categoryItem = document.createElement('div');
                categoryItem.className = 'category-color-item';
                categoryItem.innerHTML = `
                    <div class="category-info">
                        <div class="category-color-preview" id="preview-${category.replace(/[^a-zA-Z0-9]/g, '')}" style="background-color: #3498db;"></div>
                        <div>
                            <div class="category-name">${category}</div>
                            <div class="category-count">${count} project${count !== 1 ? 's' : ''}</div>
                        </div>
                    </div>
                    <div class="color-controls">
                        <input type="color" class="color-input" id="color-${category.replace(/[^a-zA-Z0-9]/g, '')}" value="#3498db">
                        <button class="generate-palette-btn" onclick="generateNewPalette('${category}')">🎲 Generate New</button>
                    </div>
                `;
                container.appendChild(categoryItem);

                // Load current color for this category
                loadCategoryColor(category);
            });
        }

        async function loadCategoryColor(category) {
            try {
                const response = await fetch(`/api/color-palette/category/${encodeURIComponent(category)}`);
                if (response.ok) {
                    const data = await response.json();
                    if (data.success && data.colors && data.colors.length > 0) {
                        const firstColor = data.colors[0].hex;
                        const categoryId = category.replace(/[^a-zA-Z0-9]/g, '');
                        document.getElementById(`color-${categoryId}`).value = firstColor;
                        document.getElementById(`preview-${categoryId}`).style.backgroundColor = firstColor;
                    }
                }
            } catch (error) {
                console.error(`Error loading color for ${category}:`, error);
            }
        }

        function generateNewPalette(category) {
            const categoryId = category.replace(/[^a-zA-Z0-9]/g, '');
            const colorInput = document.getElementById(`color-${categoryId}`);
            const preview = document.getElementById(`preview-${categoryId}`);
            
            // Generate a random color
            const randomColor = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
            colorInput.value = randomColor;
            preview.style.backgroundColor = randomColor;
        }

        // Update preview when color input changes
        document.addEventListener('change', function(e) {
            if (e.target.classList.contains('color-input')) {
                const categoryId = e.target.id.replace('color-', '');
                const preview = document.getElementById(`preview-${categoryId}`);
                if (preview) {
                    preview.style.backgroundColor = e.target.value;
                }
            }
        });

        // Save colors
        document.getElementById('save-colors-btn').addEventListener('click', async function() {
            const categoryColors = {};
            const colorInputs = document.querySelectorAll('.color-input');
            
            colorInputs.forEach(input => {
                const categoryId = input.id.replace('color-', '');
                // Find the original category name
                const categoryItem = input.closest('.category-color-item');
                const categoryName = categoryItem.querySelector('.category-name').textContent;
                categoryColors[categoryName] = input.value;
            });

            try {
                const response = await fetch('/api/color-palette/update-category-colors', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ categoryColors })
                });

                if (response.ok) {
                    const result = await response.json();
                    if (result.success) {
                        const message = result.message || 'Colors updated successfully!';
                        alert(`✅ ${message}`);
                        closeColorCustomizer();
                        // Reload the page to see changes
                        window.location.reload();
                    } else {
                        alert('❌ Failed to update colors: ' + (result.error || 'Unknown error'));
                    }
                } else {
                    alert('❌ Failed to update colors: HTTP ' + response.status);
                }
            } catch (error) {
                console.error('Error saving colors:', error);
                alert('❌ Error saving colors: ' + error.message);
            }
        });

        // Reset to defaults
        document.getElementById('reset-colors-btn').addEventListener('click', async function() {
            if (confirm('Are you sure you want to reset all colors to defaults? This will regenerate all category color palettes.')) {
                try {
                    const response = await fetch('/api/color-palette/reset-colors', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });

                    if (response.ok) {
                        const result = await response.json();
                        if (result.success) {
                            alert('✅ Colors reset to defaults!');
                            closeColorCustomizer();
                            window.location.reload();
                        } else {
                            alert('❌ Failed to reset colors: ' + (result.error || 'Unknown error'));
                        }
                    } else {
                        alert('❌ Failed to reset colors: HTTP ' + response.status);
                    }
                } catch (error) {
                    console.error('Error resetting colors:', error);
                    alert('❌ Error resetting colors: ' + error.message);
                }
            }
        });

        // Close modal when clicking outside
        window.addEventListener('click', function(event) {
            const modal = document.getElementById('color-customizer-modal');
            if (event.target === modal) {
                closeColorCustomizer();
            }
        });
    </script>
</body>
</html>
